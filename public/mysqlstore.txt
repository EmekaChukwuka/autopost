Here's the complete **ESM (ECMAScript Modules)** conversion of the MySQL backend with express-session:

### 1. Update `package.json` for ESM
```json
{
  "name": "autopost-auth",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "setup-db": "mysql -u root -p < sql/setup.sql",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.3",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "google-auth-library": "^9.6.3",
    "express-session": "^1.17.3",
    "express-mysql-session": "^2.1.8"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

### 2. Updated Server (`server.js`)
```javascript
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import session from 'express-session';
import authRoutes from './routes/authRoutes.js';
import { pool } from './config/db.js';
import sessionConfig from './config/session.js';

const app = express();

// Middleware
app.use(cors({
  origin: process.env.CLIENT_URL,
  credentials: true
}));
app.use(express.json());

// Session middleware
app.use(session(sessionConfig));

// Test database connection
pool.getConnection((err, connection) => {
  if (err) {
    console.error('MySQL connection error:', err);
    process.exit(1);
  }
  console.log('Connected to MySQL database');
  connection.release();
});

// Routes
app.use('/api/auth', authRoutes);

// Session test endpoint
app.get('/api/session-test', (req, res) => {
  if (req.session.views) {
    req.session.views++;
    res.send(`Session views: ${req.session.views}`);
  } else {
    req.session.views = 1;
    res.send('Session started! Refresh to increment views.');
  }
});

// Error Handling Middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

### 3. Updated Database Config (`config/db.js`)
```javascript
import mysql from 'mysql2/promise';

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

export { pool };
```

### 4. Updated Google Config (`config/google.js`)
```javascript
import { OAuth2Client } from 'google-auth-library';

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

const verifyGoogleToken = async (token) => {
  try {
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });
    return { payload: ticket.getPayload() };
  } catch (error) {
    return { error: "Invalid user detected. Please try again" };
  }
};

export { verifyGoogleToken };
```

### 5. Updated Session Config (`config/session.js`)
```javascript
import session from 'express-session';
import MySQLStoreFactory from 'express-mysql-session';
import { pool } from './db.js';

const MySQLStore = MySQLStoreFactory(session);

const sessionStore = new MySQLStore({
  clearExpired: true,
  checkExpirationInterval: 900000, // 15 minutes
  expiration: 86400000, // 24 hours
  createDatabaseTable: true,
  schema: {
    tableName: 'sessions',
    columnNames: {
      session_id: 'session_id',
      expires: 'expires',
      data: 'data'
    }
  }
}, pool);

const sessionConfig = {
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: sessionStore,
  cookie: {
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax'
  },
  name: 'autopost.sid'
};

export default sessionConfig;
```

### 6. Updated User Model (`models/User.js`)
```javascript
import { pool } from '../config/db.js';
import bcrypt from 'bcryptjs';

class User {
  static async create({ name, email, password, avatar, provider, verified }) {
    const hashedPassword = password ? await bcrypt.hash(password, 12) : null;
    const [result] = await pool.execute(
      `INSERT INTO users (name, email, password, avatar, provider, verified) 
       VALUES (?, ?, ?, ?, ?, ?)`,
      [name, email, hashedPassword, avatar, provider, verified]
    );
    return { id: result.insertId, name, email, avatar, provider, verified };
  }

  static async findByEmail(email) {
    const [rows] = await pool.execute(
      'SELECT * FROM users WHERE email = ? LIMIT 1',
      [email]
    );
    return rows[0];
  }

  static async findById(id) {
    const [rows] = await pool.execute(
      'SELECT id, name, email, avatar, provider, verified FROM users WHERE id = ? LIMIT 1',
      [id]
    );
    return rows[0];
  }

  static async comparePassword(email, candidatePassword) {
    const [rows] = await pool.execute(
      'SELECT password FROM users WHERE email = ? LIMIT 1',
      [email]
    );
    if (!rows[0]) return false;
    return await bcrypt.compare(candidatePassword, rows[0].password);
  }
}

export default User;
```

### 7. Updated Auth Controller (`controllers/authController.js`)
```javascript
import jwt from 'jsonwebtoken';
import User from '../models/User.js';
import { verifyGoogleToken } from '../config/google.js';

// Generate JWT Token
const generateToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN
  });
};

// Google Authentication
export const googleAuth = async (req, res) => {
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.status(400).json({ error: 'Google token is required' });
    }

    const googleData = await verifyGoogleToken(token);
    
    if (googleData.error) {
      return res.status(401).json({ error: googleData.error });
    }

    const { email, name, picture } = googleData.payload;

    // Check if user exists
    let user = await User.findByEmail(email);

    if (!user) {
      // Create new user
      user = await User.create({
        name,
        email,
        avatar: picture,
        provider: 'google',
        verified: true
      });
    }

    // Store user in session
    req.session.user = {
      id: user.id,
      name: user.name,
      email: user.email,
      avatar: user.avatar,
      provider: user.provider
    };

    // Also generate JWT for API clients if needed
    const authToken = generateToken(user.id);

    res.status(200).json({
      status: 'success',
      token: authToken, // For API clients
      sessionId: req.sessionID, // For reference
      user: req.session.user
    });

  } catch (error) {
    console.error('Google auth error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
};

// Email Signup
export const signup = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // Check if user exists
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      return res.status(400).json({ error: 'Email already in use' });
    }

    // Create new user
    const user = await User.create({
      name,
      email,
      password,
      provider: 'email'
    });

    // Store user in session
    req.session.user = {
      id: user.id,
      name: user.name,
      email: user.email,
      provider: user.provider
    };

    const authToken = generateToken(user.id);

    res.status(201).json({
      status: 'success',
      token: authToken,
      sessionId: req.sessionID,
      user: req.session.user
    });

  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
};

// Email Login
export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Check if user exists
    const user = await User.findByEmail(email);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await User.comparePassword(email, password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Store user in session
    req.session.user = {
      id: user.id,
      name: user.name,
      email: user.email,
      avatar: user.avatar,
      provider: user.provider
    };

    const authToken = generateToken(user.id);

    res.status(200).json({
      status: 'success',
      token: authToken,
      sessionId: req.sessionID,
      user: req.session.user
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
};

// Get current user from session
export const getMe = async (req, res) => {
  try {
    if (!req.session.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    res.status(200).json({
      status: 'success',
      user: req.session.user
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
};

// Logout
export const logout = async (req, res) => {
  try {
    // Destroy session
    req.session.destroy((err) => {
      if (err) {
        console.error('Logout error:', err);
        return res.status(500).json({ error: 'Logout failed' });
      }
      
      // Clear session cookie
      res.clearCookie('autopost.sid');
      
      res.status(200).json({
        status: 'success',
        message: 'Logged out successfully'
      });
    });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Logout failed' });
  }
};

// Check session status
export const sessionStatus = async (req, res) => {
  try {
    if (req.session.user) {
      res.status(200).json({
        status: 'success',
        authenticated: true,
        user: req.session.user
      });
    } else {
      res.status(200).json({
        status: 'success',
        authenticated: false
      });
    }
  } catch (error) {
    console.error('Session status error:', error);
    res.status(500).json({ error: 'Failed to check session status' });
  }
};
```

### 8. Updated Auth Routes (`routes/authRoutes.js`)
```javascript
import express from 'express';
import {
  googleAuth,
  signup,
  login,
  getMe,
  logout,
  sessionStatus
} from '../controllers/authController.js';

const router = express.Router();

router.post('/google', googleAuth);
router.post('/signup', signup);
router.post('/login', login);
router.get('/me', getMe);
router.post('/logout', logout);
router.get('/status', sessionStatus);

export default router;
```

### 9. Updated Middleware (`middlewares/authMiddleware.js`)
```javascript
import jwt from 'jsonwebtoken';

// Middleware to check if user is authenticated via session
export const requireAuth = (req, res, next) => {
  if (!req.session.user) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  next();
};

// Middleware to check if user is authenticated via JWT (for API clients)
export const requireAuthJWT = (req, res, next) => {
  let token;
  
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ error: 'Not authorized, no token' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = { id: decoded.id };
    next();
  } catch (error) {
    console.error('JWT auth error:', error);
    res.status(401).json({ error: 'Not authorized, token failed' });
  }
};
```

### 10. Environment Variables (`.env`)
```env
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_mysql_password
DB_NAME=autopost
GOOGLE_CLIENT_ID=your-google-client-id.apps.googleusercontent.com
JWT_SECRET=your_jwt_secret_here_make_it_strong
JWT_EXPIRES_IN=30d
SESSION_SECRET=your_session_secret_here_make_it_long_and_secure
CLIENT_URL=http://localhost:3000
PORT=5000
NODE_ENV=development
```

### Key ESM Changes:

1. **Import/Export Syntax**:
   - Changed `require()` to `import`
   - Changed `module.exports` to `export`
   - Added `.js` extensions to imports

2. **Package.json**:
   - Added `"type": "module"`

3. **Dynamic Imports**:
   - For conditional imports, use: `import('package').then(module => {...})`

4. **File Extensions**:
   - All imports must include file extensions (`.js`, `.json`, etc.)

### Running the Application:

1. **Install Dependencies**:
```bash
npm install
```

2. **Setup Database**:
```bash
npm run setup-db
```

3. **Start Development Server**:
```bash
npm run dev
```

### Client-Side Usage (Frontend):
```javascript
// All frontend code remains the same
// Ensure you include credentials: 'include' for session cookies

fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include', // Crucial for session cookies
  body: JSON.stringify({ email, password })
});
```

This ESM conversion maintains all the functionality while using modern JavaScript module syntax. The application structure and API endpoints remain identical to the CommonJS version.